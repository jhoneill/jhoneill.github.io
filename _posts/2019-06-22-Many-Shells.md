---
layout: post
title:  "Last time I saw this many shells, someone sold them by the sea shore."
date:   2019-06-22
categories: PowerShell
tags:
    - Windows Subsystem for Linux
    - WSL
    - Windows Terminal
    - Remoting
---
I’ve been experimenting with lots of different combinations of shells on Windows 10.

<a href="/assets/shells1.png"><img style="float:right;display:inline;" border="1" alt="Bash in WSL" src="/assets/shells1.png" width="516" align="right" height="157" /></a> 

BASH.  I avoided the Subsystem for Linux on Windows 10 for a while. There are only [two steps](https://docs.microsoft.com/en-us/windows/wsl/install-win10) to set it up – adding the Subsystem, and adding your chosen Linux to it. If the the idea of installing Linux into Windows, but _not_ as a virtual machine, and getting it from the Windows store gives you a headache, you’re not alone, this may help or it make things worse. I go back to the first versions of Windows NT which had a Windows-16 on Windows-32 subsystem (WoW, which was linked to the Virtual Dos Machine – <u>32-bit</u> Windows 10 can still install these), an OS/2 subsystem, and then a Posix subsystem. Subsystems translated APIs so binaries intended for a different OS could run on NT, but kernel functions (drivers, file-systems, memory management, networking, process scheduling) – remained the responsibility of underlying OS. 25 years on, the Subsystem for Linux arrives in two parts – the Windows bits to support all the different Linuxes, and then distributor-supplied bits to make it look like Ubuntu 18.4 (which is what I have) or Suse or whichever distribution you chose. `wslconfig.exe` will tell you which distro(s) you have and change the active one. There is a generic launcher `wsl.exe` which will launch any Linux binary in the subsystem so you can run `wsl bash` but a Windows executable, `bash.exe` streamlines the process

<a href="/assets/shells2.png"> <img style="float:left;display:inline;" border="1" alt="WSL in the Windows file system" src="/assets/shells2.png" width="281" align="left" height="378">

Linux has a view of Windows’ files (C: is auto-mounted at `/mnt/c` and the `mount` command will mount other Windows filesystems including network and removable drives) but there is strongly worded advice not to touch Linux’s files via their location on C: – see [here](https://devblogs.microsoft.com/commandline/do-not-change-linux-files-using-windows-apps-and-tools/) for more details. – Just before publishing this I updated the 1903 release of Windows 10 which adds a proper access which you can see in the screen shot.
 
**Subsystem processes aren’t isolated** – although a Linux API call might have a restricted view of the system. For example `ps` only sees processes in the subsystem but if you start two instances of `bash`, they’re both in the subsystem they can both see each other and running `kill` in one will terminate the other. The subsystem can run a Windows binary (like `net.exe` start which will see Windows services) and pipe its output into an Linux one, like `less`;  those who prefer some Linux tools get to use them in their management of Windows.

The **subsystem isn’t read-only** – anything which changes in that filesystem stays changed – since the subsystem starts configured for US Locale,    
`sudo locale-gen en_GB.UTF-8` and `sudo update-locale LANG=en_GB.UTF-8` got me to a British locale. 

Being writable meant I could install **PowerShell core for Linux** into the subsystem: I just followed [the instructions](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-6) (including running `sudo apt-get update` and `sudo apt-get upgrade powershell` to update from 6.1 to 6.2). Now I can test whether things which work in Windows PowerShell (V5), also work with PowerShell Core (V6) on different platforms.  I can tell the Windows Subsystem for Linux to go straight into PowerShell with `wsl pwsh` (or `wsl pwsh –nologo` if I’m at a command line already). Like bash it can start Windows and Linux binaries and the “in-the-Linux-subsystem” limitations still hold. `Get-Process` asks about processes in the subsystem, not the wider OS. Most PowerShell commands are there; some familiar aliases overlap with Linux commands and most of those have been removed (so `| sort` will send something to the Linux sort, not to `sort-object`,  and `ps` is _not_ the alias for Get-Process;  kill and cd are exceptions to this rule.). Some common environment variables (Temp, TMP, UserProfile, ComputerName) are not present on Linux, and Windows specific cmdlets, like `Get-Service`,  don’t exist in the Linux world, and tab expansion switches to Unix style by default but you can set either environment to match the other. My **PowerShell Profile** soon gained a `Set-PsReadlineOption` command to give me the tab expansion I expect and it sets a couple of environment variables which I know some of my scripts use.  It’s possible (and tempting) to create some PSDrives which map single letters to places on `/mnt`, but things like to revert back to the Linux path. After that V6 core is the same on both platforms

**PowerShell on Linux has remoting over SSH**; it connects to another instance of PowerShell 6 running in what SSH also terms a “subsystem”. Windows PowerShell (up to 5.1) uses WinRM as its transport and PowerShell Core (6) on Windows can use both. For now at least, options like constrained endpoints (and hence “Just Enough Admin”  or JEA), are only in WinRM.
The instructions for setting up OpenSSH are [here](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-6); I spent a very frustrating time editing the wrong config file – there is one in with the program files, and my brain filtered out the instruction which said edit the sshd_config file in <u>C:\Program Data\ssh</u>. I edited the one in the wrong directory and could make an SSH session into Windows (a useful thing to know to prove Open SSH is accepting connections) but every attempt to create a PowerShell session gave the error   
<code><font color=red>New-PSSession : [localhost] The background process reported an error with the following message: The SSH client session has ended with error message: subsystem request failed on channel 0.</font></code>    
When I (finally) edited the right file I could connect to it from both Windows and Linux versions of PowerShell core with `New-PSSession -HostName localhost`.  (Using `–HostName` instead of `–Computername` tells the command “This is an SSH host, not a WinRM one”). It always amazes me how people, especially but not exclusively those who spend a lot of time with Linux, are willing to re-enter a password again and again and again. I’ve always thought it was axiomatic that a well designed security system granted or refused access to many things without asking the user to re-authenticate for each (or “If I have to enter my password once more, I’ll want the so-called ‘Security architect’ fired”). So within 5 minutes I was itching to get SSH to sign in with a certificate and not demand my password.


<a href="/assets/shells3.png"><img style="float:right;display:inline;" border="1" alt="PowerShell remoting from WSL to Windows" src="/assets/shells3.png" width="515" align="right" height="107" /></a> 


I found some help [here](https://4sysops.com/archives/powershell-remoting-with-ssh-public-key-authentication/), but not all the steps are needed. Running the `ssh-keygen.exe` utility which comes with OpenSSH builds the necessary files – I let it save the files to the default location and left the passphrase for the file blank, so it was just a case of hitting enter for each prompt. For a trivial environment like this I was able to copy the `id_rsa.pub` file to a new file named `authorized_keys` in the same folder, but in a more real world case you’d copy and paste each new public key file into authorized_keys, then I could test a Windows to Windows remoting session over SSH. When that worked I copied the `.ssh` directory to my home directory in the Subsystem for Linux, and the same command worked again.

<a href="/assets/shells4.png"> <img style="float:left;display:inline;" border="1" alt="Pie chart of command availablity" src="/assets/shells4.png" width="464" align="left" height="277"></a>

**PowerShell Core V6 is built on .NET core**, so some parts of PowerShell 5 have gone missing: there’s no `Out-Grid`, or `Show-Command`, No `Out-Printer` (I wrote a [replacement](https://www.powershellgallery.com/packages/6print)]), no WMI commands, no commands to work with the event log, no transactions and no tools to manage the computer’s relationship with AD.  The `Microsoft.*` modules provide about 312 commands in V5.1 and about 244 of those are available in V6; but nearly 70 do things which don’t make sense in the Linux world because they work with WinRM/WSMan, Windows security or Windows services. A few things like renaming the computer, stopping and restarting it, or changing the time zone need to be done with native Linux tools. But we have just over 194 core cmdlets on all platforms, and more in pre-installed modules. There was a also a big step forward with compatibility in PowerShell 6.1 and another with 6.2 – there is a support for a lot more of the Windows API, so although some things don’t work in Core, a lot more does than at first release. It may be necessary to specify the explicit path to the module (the different versions use either “…\WindowsPowerShell\…” or “..\PowerShell\…” in their paths and Windows tools typically install their modules for _Windows_ PowerShell) or to use `Import-Module` in V6 with the `–SkipEditionCheck` switch. Relatively few stubbornly refuse to work, and there is a solution for them: **remotely run the commands that otherwise** are unavailable – instead of going over SSH this time you use WinRM, (V5 doesn’t support SSH). When I started working with [constrained endpoints](/powershell/2016/06/29/Jea1.html), I found I liked the idea of not needing to install modules everywhere and running their commands remotely instead, once you have a PSSession to the place where the commands exist, you can use `Get-Module` and `Import-Module` with a `–PsSession` switch, to make them available. So we can bridge between versions – “the place where the commands exist” is “another version of PowerShell on the same machine” it’s all the same to remoting. [The PowerShell team have announced](https://devblogs.microsoft.com/powershell/powershell-7-road-map/) that the next release uses .Net core 3.0 which should mean the return of `Out-Gridview` (eventually), and other home brew tools to put GUI interfaces onto PowerShell; that’s enough of a change to  bump the major version number, and they will drop “Core” from the name to try to remove the impression that it is a poor relation on Windows. The PowerShell team have a script to do a side by side install of the preview – or even the daily builds – Thomas Lee wrote it up [here](https://tfl09.blogspot.com/2019/06/like-many-it-pros-ive-been-waiting-on.html). Preview 1 seems to have done the important but invisible work of changing .Net version; new commands will come later; but at the time of writing **PowerShell 7 preview has parity with PowerShell Core 6**, and the goal is parity with Windows PowerShell 5

There is no ISE in PowerShell 6/7, Visual Studio Code _had_ some real annoyances but pretty well all of them have been fixed for some months now and somewhere I joined the majority who see it as the future. Having a Git client built-in has made collaborating on the ImportExcel module so much easier, and that got me to embrace it. _Code_ wasn’t built specifically for PowerShell which means it will work with whichever version(s) it finds.  

<a href="/assets/shells5.png"> <img style="float:left;display:inline;" border="1" alt="Status bar in VSCode" src="/assets/shells5.png" width="240" align="left" height="37"></a>

The right of the status bar looks like this and clicking the green bit pulls up a menu where you can swap between versions and test what you are writing in each one. These swaps close one instance of PowerShell and open another so you know you’re in a clean environment (not always true with the ISE); the flip side is you realise it is a clean environment when you want something which was loaded in the shell in the shell you’ve just swapped away from. 
VS Code’s architecture of _extensions_ means it can pull all kinds of clever tricks – like remote editing –and the Azure plug in allows an **Azure Cloud Shell** to be started inside the IDE. 

<a href="/assets/shells6.png"><img style="float:right;display:inline;" border="1" alt="VS Code Remoting" src="/assets/shells6.png" width="515" align="right" height="100" /></a> 


When you use Cloud Shell in a browser it has nice easy ways to transfer files; but you can discover the UNC path to your cloud drive with `Get-cloudDrive` then `Get-AzStorageAccount` will show you a list of accounts, you can work out the name of the account from the UNC path and you use this as the user name to logon but you also need to know the resource group it is in, and `Get-AzStorageAccount` shows that. Armed with the name and resource group `Get-AzStorageAccountKey` gives you one or more keys which can be used as a password, and you can **map a drive letter to the cloud drive.**

Surely that’s enough shells for one post … well not quite. People have been getting excited about the new [Windows Terminal](https://devblogs.microsoft.com/commandline/introducing-windows-terminal/) which is went into preview in the Windows store a few hours before I first posted this; before that you needed to enable developer options on Windows and build it for yourself. It needs the 1903 Windows update and with that freshly installed I thought “I’ve also got [full] Visual Studio on this machine, why not build and play with Terminal”. As it turns out I needed to add the latest Windows SDK and several gigabytes of options to Visual Studio (all described on the github page), but with that done it was one git command to download the files, another to get submodules, then open visual studio, select the right section per the instructions and say build me an X64 release, have a coffee … and the app appears. (In the limited time I’ve spent with version in store it looks to be the same as the build-your-own version).

<a href="/assets/shells7.png"> <img style="float:left;display:inline;" border="1" alt="Windows Terminal 0.3" src="/assets/shells7.png" width="715" align="left" height="187"></a>

It’s nice, despite being early code (no settings menu, just a json file of settings to change)., It’s the first time time Microsoft have put out a replacement for the host which Window uses for command line tools – shells or otherwise, so you could run ssh, ftp, or a tool like netsh in it.  I’ve yet to find a way to have “as admin” and normal processes running in one instance. It didn’t take long for me to add PowerShell on Linux and PowerShell 7 preview to the default choices (it’s easy to copy/paste/adjust the json – just remember to change the guid when adding an new choice, and you can specify the path to a PNG file to use as an icon).
So, in a single window, I have all the shells, except for 32-bit PowerShell 5, as tabs:  CMD, three different, 64-bit versions of PowerShell on Windows, PowerShell on WSL, BASH on WSL, and PowerShell on Linux in Azure.
I must give a [shout out to Scott Hanselman](https://www.hanselman.com/blog/AnExperimentTheAzureCloudShellAtTheCommandLineWithAZSHELL.aspx) for the last one; I was thinking “there must be a way to do what VS code does” and from his post Scott thought down the same lines a little while before me. He hooked up with others working on it and shared the results. I use a 2 line batch file with `title` and azshell.exe (I’m not sure when “title” crept into CMD, but I’m fairly sure it wasn’t always there. I’ve used it to keep the tab narrow for CMD: to set the tab names for each of the PowerShell versions I set `$Host.UI.RawUI.WindowTitle` which even works with from WSL) [**UPDATED 3 Aug 2019**. Terminal 0.3 has just been releases with an Azure option which starts the cloud shell, but only in its bash incarnation. `AzShell.exe` can support a choice of shell by specifying `–shell pwsh` or `–shell bash` ] 
So I get 7 Shells, 8 if I added the 32 bit version of PowerShell. Running them in the traditional host would give me 16 possible shells. Add the 32 and 64 bit PowerShell ISEs and VS code with Cloud shell and 3 Versions of local PowerShell, and we’re up to 22. And finally there is Azure cloud shell in a browser or, if you must, the azure phone app, so I get to an nice round **two dozen shells** in all without ssh’ing into other machines (yes terminal can run ssh)WIl, using any of the alternate Linux shells with WSL or loading all the options VS code has. “_Just type the following command line_” is not as simple as it used to be.
